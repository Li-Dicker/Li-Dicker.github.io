<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利与弊</title>
      <link href="%E6%96%87%E7%AB%A0/%E5%88%A9%E4%B8%8E%E5%BC%8A/%E5%88%A9%E4%B8%8E%E5%BC%8A/"/>
      <url>%E6%96%87%E7%AB%A0/%E5%88%A9%E4%B8%8E%E5%BC%8A/%E5%88%A9%E4%B8%8E%E5%BC%8A/</url>
      
        <content type="html"><![CDATA[<p>人是一种片面的动物，总想着顾全大局，却又总是因为少数缺点放弃了所有优点。人是一种贪心的动物，总认为局部最优解一定是全局最优解。</p><p>人类的本质不过如此，在全局利与弊之间选择了对自己最轻松的最好的解，以至于几千年的地球文明发展至今也不过如此。</p><p>他们从来不会担心，缺点的背后是什么；他们从来不会想到，蝴蝶效应就在身边，一次决定就会改变许多人，甚至全世界。</p><a id="more"></a><p>我养过的第一只狗，他与我相处的时间只有短短的22个小时。给我留下的不甘与痛楚却是一辈子。</p><p>他叫旺旺，是一只两个月大的金毛。或许今后我还会拥有另一只旺旺，但他却是独一无二的—给我留下独一无二的回忆。养他之前，我不止一次的想过：当他到来，我们的家会是什么样子？我又会是什么样子？是会好吗？还是更烂？没想到对我而言是另一天。</p><p>我曾经堕入无边黑暗，只想永远地离开；我曾经毁了我的一切，想挣扎无法自拔。但是他到来的时候，我的人生进入了另一天。晴天。万里无云的晴天。或许对于我的整个家庭而言，都是晴天。他跟着我跳，尾巴也充满了活力地摇；我没见过狗狗笑，但是他却让我难得的笑了，笑得那么纯真，那么灿烂，那么阳光。那纯真，能净化所有的污渍；那灿烂，能比过漫天的烟火；那阳光，能突破所有的黑暗。带我走出黑暗的他，独一无二的他。</p><p>丁真的笑容火遍了全网，只因为纯真。大家都说，那是最纯真的笑容。可是渐渐的，渐渐的，那笑容开始弥漫一股金属的味道，一股数字的味道，一股死气沉沉的味道。被商业化，被网络化，被利用，被经济支配，便跌落谷底，无论如何洗白无法东山再起。</p><p>带回家的第二天早上，旺旺就吐了。我带着他去医院，满怀信心的去医院，迎接的却是更深层的黑暗。三种传染病他带上了两种—细小和冠状。我含着泪回家，终于在被询问他状态的一刻崩溃，跌入更深的谷底。无能，他被送走，送回原处。我没说话，只是默默地感受后脑勺的爆炸。</p><p>我淡淡地说我再也不想养狗了。妈点了点头，很满意。而后不久，我开始反悔了。孤独再次侵蚀我的身体，侵蚀我的灵魂，无法忍受，难以入眠。好不容易将妹妹安抚下来，我又找到妈，告诉她，我反悔了。换来的只有无奈与不同意。原因只是：太难打扫，没时间陪他。</p><p>我疑惑，难道优点不是比这个多很多吗？难道就因为这些就放弃了他的所有优点吗？人类为什么只能做一种这么片面的动物，因为1，就要放弃100吗？利与弊的平衡，难道就这么难吗？</p><p>直升考试之后，我也面临留下还是放弃的问题。我尝试着用一张纸，列举出放弃或者留下的所有利与弊，对比之下，我很轻易地做出了决定。以至于之后许多人在问我这些问题的时候，我都会告诉他们这些方法。但面临这件事情，我再次这样，却发现利弊似乎均衡了。但是明明一只狗影响的不止我一个人，为什么还会这样呢？我尝试将影响全局的利弊乘以人数，一切都了然了。</p><p>权衡利与弊就像经济学，却又不像经济学。如果权衡利弊是共产主义，那么经济学一定是资本主义了：他总是以1%的人为中心来思考%99的人的利益。或许这就是中国之所以强大的原因吧。在中国又许多亏损的项目：中国邮政，中国电网，中国高铁，哪一项项目不是在亏损运行？但是，因为权衡利弊，他们带来了更大的收获，让更多人得到了更好的生活。这才是我们该追求的。</p><p>我恨经济学，不仅仅因为他是资本主义，更重要的是，它改变了人类，也改变了人类；它改变了世界，也改变了世界。正确的权衡利弊，就是经济学的最高境界，就好像资本主义的最高境界，就是共产主义。</p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 感悟 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My 2020</title>
      <link href="%E6%96%87%E7%AB%A0/My-2020/my-2020/"/>
      <url>%E6%96%87%E7%AB%A0/My-2020/my-2020/</url>
      
        <content type="html"><![CDATA[<p>我的2020，可以用“极端”来形容吧。是不是好到了极端我不知道，但是或许会有坏到了极端。这或许也是我现在情绪的状态。</p><p>或许这一年我经历了自己最意想不到的事情：找到了自己拼命喜欢的人，攀登到了自己想不到的位置；失去了自己拼命喜欢的人，跌落到了自己想不到的位置。这些，都是极端中的极端，好多戏剧一般的东西，都在我的生活中慢慢上演。或许我的生活本身就只是一场拙劣的戏，我只是其中的一个小演员，却偏偏以为自己是世界的主角。</p><p>我以为这一年的最后两天能顺利度过，却没想到命运给了我太大的惊喜。连续5此咬到自己的嘴巴，连打哈欠都可以咬到；走在路上能把一坨狗屎踩个正着；晚上看风景的时候拍照手机突然关机两次；打开电脑准备写点什么的时候电脑又蓝屏；蓝屏完了之后终于打开Typora却发现这玩意软件出问题了；去官网上下载卡在了还剩7秒的时候…或许这是一部辛酸史，要是把这剧情写进考场作文描述自己的衰估计都会被老师说太老套太不真实…</p><p>对于2020，我还有什么话可说呢？欠下的一屁股债现在还没还清（真的很内疚但是也真的没法），自己的身体也时常不争气，分分合合又合合分分的感情让人心累不想参与，想拼尽全力学习的时候却真的什么动力都找不到。</p><p>或许只是一些牢骚，发完了就好了吧。</p><p>不敢多写了，因为太多的事情牵涉了太多的人引出了太多的事。</p><p>愿新的一年，一切都能好起来。我也是。</p><p>再见，2020；你好，2021。</p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 感悟 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不想再爱这个世界</title>
      <link href="%E6%96%87%E7%AB%A0/%E4%B8%8D%E6%83%B3%E5%86%8D%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C/%E4%B8%8D%E6%83%B3%E5%86%8D%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C/"/>
      <url>%E6%96%87%E7%AB%A0/%E4%B8%8D%E6%83%B3%E5%86%8D%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C/%E4%B8%8D%E6%83%B3%E5%86%8D%E7%88%B1%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>热力学第二定律告诉我们，这是一个熵增的世界。也就是说，万物都会从纯净变得混杂。人心不也是这样吗。</p><p>我们从小就会背的“人之初，性本善”，但现在想起，为何这么多年来读起这个句子，内心居然没有一丝波澜，没有一丝惋惜？对这个世界的惋惜。</p><p>或许人性之本的善来自于感性，因为这时候的孩子还丝毫不了解这个世界，还没有一丝理性，感性支配着他们的生活。不舒服了，就哭，哭完了才舒服；开心了，就笑，笑起来能给大家都带来欢乐。而逐渐地，知识进入孩子们的世界，理性开始征服感性，大脑前额开始出现true or false的观念。这时候他们基本知道，什么应该，什么不该。感性告诉孩子，接受理性，能让你更加了解这个世界。于是孩子们有了求知欲，开始疯狂汲取知识，让自己变得更理性。</p><p>人本是感性的动物，却逐渐被理性支配，最后从理性当中发现自我。理性让我们发现了热力学第二定律，热力学第二定律告诉我们这个世界是熵增的，熵增说明了人心也会越来越复杂，也就是理性与感性会越来越混杂。但这本身是一个矛盾。老人们常说自己老糊涂了，但这是真的糊涂吗？还是说只是越来越感性了，开始逐渐摒弃自己的理性，回到最开始的模样？人的一生或许只是一个山峰，不同时代的人经历的山也不同，无论是陡峭程度，还是山峰的高度。我们从完全感性开始，生活逐渐充满理性，到最后又逐渐摒弃理性，回到梦开始的地方。</p><p>在理性的世界中，每一件事情都应该是true or false，每一个问题都应该有答案。然而这个世界上往往有一些问题不能用理性的思维来找到答案，于是人们又开始回归感性，思考这个世界，思考这个世界的目的；思考自己的人生，思考自己人生的目的。</p><p>我们追寻感性的答案，却选择了通过理性来寻找它，这不也是一个矛盾吗？</p><a id="more"></a><p>所以这个世界上每天都会有很多人自杀。有的人自杀了，换来的是许多人的关注；有的人自杀了，换来的只是周围人的饭后闲谈。他们为什么要自杀？除开那些意气用事的人，或许他们才是人生的赢家，看透了这个世界，找到了世界的目的，找到了世界的意义。或许他们也知道，自己终究会死，自己在世界上的一切都会失去，自己在这个世界上的一切欢乐终将变成最终离开时的痛苦。欢乐越多，牵挂越多，最后的痛苦也越多。他们知道自己脚下的这座山会越来越陡峭，越往上越痛苦，还不如就此回头，放下一切。他们清楚，这是个绝对不公平的世界，哪怕总有人每天都强调公平，那也只能是相对的，表面上的。他们清楚这是个物质的世界，这是个黑暗的世界，这是个黑暗的宇宙。因为时间，你努力一辈子的天花板或许还不如别人的起点。</p><p>所以我们总是幻想着自己是这个世界的主角，自己是这个世界的一切。但这永远只是幻想。血淋淋的事实摆在面前，无论是感性还是理性理解，都只能给自己带来无数的压抑情绪，让自己崩溃，让自己不想再爱这个世界。或许这个世界本身就不值得我们去爱。</p><p>我们辗转反侧，我们不停的在房间踱步，觉得自己真的应该努力，想用理性认清现实，告诉自己再不努力真的就来不及了，但一日复一日，我们已经无能努力，只剩下绝望，与失魂的躯体。</p><p>我们一次又一次的矛盾，一次又一次的束手无策，因为这个世界充满了竞争。我们站在独木桥上，想要前行，或许只能推下前方的一个又一个同行的伙伴。内心，是多么煎熬，多么痛苦，多么不舍。我们只能无声地反抗，最后推下前方的人，成为自己最恨的那个人。</p><p>我们回首望去，看着自己丢失的一分一秒的光影，看着自己与别人的差距越来越大，开始着急开始焦虑，烦躁逐渐从心里扩散到身上。过去已经不能弥补，那我还要不要努力？我还能不能做回自己？</p><p>我们看清这世界，看着这结局早已注定的世界，看着自己从能顶天立地变成废物，开始无奈开始抑郁，疼痛慢慢从心里扩散到身上。结局已经注定，那我还要不要尝试？我还能不能做回自己？</p><p>所以我们想过离开，永远地离开。我们以这种方式存在，注定只是个错误吧？这个世界本来就不公平，那为什么还要努力呢？结局早已注定，这个世界已经没救了，被遗忘的人们为什么还要自救呢？不如就这样永远地离开吧，痛苦就在那一瞬间，美好的还有一瞬间之后的永远。活着，还要承受那些旁白，那些姿态，那些伤害。</p><p>可是我们不想离开，真的不想离开。每一次准备离开，总会有一个人走到你身旁，轻轻的说上一句：别怕，我来拯救你了。那瞬间，眼泪流下，真心也留下，不想离开这个世界的愿望也留下。那瞬间，忽然，我开始莫名期待，期待这个世界，期待未来，期待有你们的未来。</p><p>我们的世界，阳光败给了阴霾，生活失去了色彩。我们一次又一次的无助与绝望，一次又一次的寻求帮助，却总是没有响应。没想到，这片阴霾，你会为我拼命拨开，给我的未来带来希望。你的笑容绽开，我的生活突然就突然了色彩。</p><p>忽然发现，这一切又是一个矛盾，一个巨大的矛盾。我到底要不要离开？这个世界到底值不值得我爱？</p><p>或许这个世界是一个环，是一个感性的环，小环形成大环，大环形成更大的环，最后构成人生的环，一个超越时间的环。我们从完全感性开始，再慢慢吸收理性，最后慢慢摒弃理性，回到开始。这不就是一个环吗？</p><p>但是环也有大小之分，有方圆之分。我们要离开，也要让自己人生的环变得更大，更圆。说不定某一天，你的环，就带动了他人的环，让他人变得爱这个世界，让这个世界变得值得被爱。</p><p>自杀的人或许是人生赢家，当然，只是或许。因为真正的人生赢家，不会自杀，而是会默默地忍受生活的痛楚，在需要自己的时候奉献自己，让自己的环带动他人，这才是人生的意义，这样才能影响世界的目的，这才是我的英雄主义。</p><p>不想爱这个世界，那就别爱这个世界了，多爱一下自己吧，这样才能更好的爱别人。</p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="uncategorized/hello-world/hello-world/"/>
      <url>uncategorized/hello-world/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="OI/%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>OI/%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>一、思想 </strong></p><ul><li><strong>分解</strong>：通过二分的思想，将序列多次拆分成一个又一个的小区间。类似于线段树在build的时候会把整个序列分割成一个又一个小区间直到无法继续分割。</li><li><strong>排序</strong>：对拆分好的每一个小区间进行排序。通过局部有序然后向上合并达到全局有序。</li><li><strong>合并</strong>：把两个已经排序好的小区间合并成一个较大的小区间。向上更新区间，从小区间向上推。</li></ul><p><strong>二、实现过程</strong></p><ol><li><strong>拆分与排序 </strong></li></ol><p><img data-src="1.png" alt="拆分与排序"></p><ol><li><strong>合并过程</strong></li></ol><p><img data-src="2.png" alt="合并过程"></p><a id="more"></a><p><strong>三、复杂度</strong></p><ol><li><strong>时间复杂度</strong>：由于会有一个二分的操作，所以是有一个$ log$级别的操作。因为对每一个区间都要进行整理顺序并且合并，对每个区间的操作是$ O(len)$的时间复杂度（$len$代表区间的长度）。因为是二分的区间，所以最终时间复杂度是$O(nlogn)$。</li><li><strong>空间复杂度</strong>：因为需要一个新数组作为两个连续的小区间的合并区间，所以空间复杂度为$O(n)$。</li><li><strong>算法稳定性</strong>：因为首先需要对数组拆分，并且对拆分出来的每一个小区间都需要扫描一遍来排序。所以无论数列的顺序如何，算法的复杂度都是$O(nlogn)$。所以是稳定的排序算法。</li></ol><p><strong>四、代码实现</strong></p><ol><li><p><strong>main函数部分</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">merge_sort(<span class="number">1</span>,n);<span class="comment">//对这个数组的1到n进行排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,a[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>拆分部分</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l==r)<span class="comment">//拆分到底的情况</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//二分继续拆分</span></span><br><span class="line">merge_sort(l,mid);<span class="comment">//左子区间</span></span><br><span class="line">merge_sort(mid+<span class="number">1</span>,r);<span class="comment">//右子区间</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>排序并合并部分</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line"><span class="comment">//i代表左区间目前扫描到的数的位置，j代表右区间目前扫描到的数的位置</span></span><br><span class="line"><span class="comment">//k代表合并区间目前最后一个数在合并区间的位置，对应的是合并之后这个元素在原序列中的位置</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=r)<span class="comment">//保证i一定在左区间并且j一定在右区间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]&lt;=a[j])<span class="comment">//左区间的第一个数大于右区间的第一个数 </span></span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[i];<span class="comment">//comb代表合并在一起的区间，临时存储</span></span><br><span class="line">i++;<span class="comment">//准备扫描左区间下一个数</span></span><br><span class="line">k++;<span class="comment">//合并区间里面的元素个数加加</span></span><br><span class="line">&#125;<span class="comment">//左区间的第一个数按顺序放在合并区间</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//右区间的第一个数大于左区间的第一个数 </span></span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[j];</span><br><span class="line">j++;</span><br><span class="line">k++;<span class="comment">//同上理</span></span><br><span class="line">&#125;<span class="comment">//右区间的第一个数按顺序放在合并区间</span></span><br><span class="line">&#125;<span class="comment">//这样操作之后左区间或者右区间有可能没被扫描完，因为i和j有一个会先到达边界</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)    </span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[i];</span><br><span class="line">i++;</span><br><span class="line">k++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;=r)     </span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="comment">//把这两个小区间没有分到合并区间都分过去</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>复原部分</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">a[i]=comb[i];<span class="comment">//把原来的两个区间更新为现在已经找计算来的合并区间</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>完整代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 111111</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N],comb[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r)<span class="comment">//拆分到底的情况</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//二分继续拆分</span></span><br><span class="line">merge_sort(l,mid);<span class="comment">//左子区间</span></span><br><span class="line">merge_sort(mid+<span class="number">1</span>,r);<span class="comment">//右子区间</span></span><br><span class="line"><span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line"><span class="comment">//i代表左区间目前扫描到的数的位置，j代表右区间目前扫描到的数的位置</span></span><br><span class="line"><span class="comment">//k代表合并区间目前最后一个数在合并区间的位置，对应的是合并之后这个元素在原序列中的位置</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=r)<span class="comment">//保证i一定在左区间并且j一定在右区间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]&lt;=a[j])<span class="comment">//左区间的第一个数大于右区间的第一个数 </span></span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[i];<span class="comment">//comb代表合并在一起的区间，临时存储</span></span><br><span class="line">i++;<span class="comment">//准备扫描左区间下一个数</span></span><br><span class="line">k++;<span class="comment">//合并区间里面的元素个数加加</span></span><br><span class="line">&#125;<span class="comment">//左区间的第一个数按顺序放在合并区间</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//右区间的第一个数大于左区间的第一个数 </span></span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[j];</span><br><span class="line">j++;</span><br><span class="line">k++;<span class="comment">//同上理</span></span><br><span class="line">&#125;<span class="comment">//右区间的第一个数按顺序放在合并区间</span></span><br><span class="line">&#125;<span class="comment">//这样操作之后左区间或者右区间有可能没被扫描完，因为i和j有一个会先到达边界</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)    </span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[i];</span><br><span class="line">i++;</span><br><span class="line">k++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;=r)     </span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="comment">//把这两个小区间没有分到合并区间都分过去</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;i++)   </span><br><span class="line">a[i]=comb[i];<span class="comment">//把原来的两个区间更新为现在已经找计算来的合并区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">merge_sort(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,a[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>五、应用：求逆序对</strong></p></li></ol><blockquote><p>  设A为一个有n个<a href="https://zh.wikipedia.org/wiki/数字">数字</a>的<a href="https://zh.wikipedia.org/w/index.php?title=有序集&amp;action=edit&amp;redlink=1">有序集</a>（n&gt;1），其中所有数字各不相同。如果存在正整数i, j使得1 ≤ i ＜ j ≤ n而且A[i] ＞ A[j]，则<A[i], A[j]>这一个<a href="https://zh.wikipedia.org/wiki/有序对">有序对</a>称为A的一个<strong>逆序对</strong>，也称作逆序。逆序对的数量称作逆序数。—-摘自<a href="https://zh.wikipedia.org/wiki/%E9%80%86%E5%BA%8F%E5%AF%B9">维基百科</a></p></blockquote><p>例如，一个数列$ 1,3,2,4,5$,那么其中$3,2$是一个逆序对。这个数列中，逆序对的个数为1.</p><p>那么我们首先想到求逆序对的方法一定是暴力枚举两个数，看他们是否成逆序对。但这样的时间复杂度太高了，为$O(n)$。</p><p>那逆序对和归并排序有什么关系呢？</p><p>我们再来温习一下归并排序合并的过程。</p><p>首先，对于两个小区间，要将他们合并成一个大区间，必然会在两个小区间从头开始扫描过去，例如下图：</p><p><img data-src="4.png" alt="逆序对-1"></p><p>这个图中，我们会先把$1$放在合并区间中，再把$2$放入区间中。然后我们会发现，右区间的$1$与左区间的四个数都构成逆序对。</p><p>继续扫描，将2放入区间中，$2$与左区间的四个数也构成逆序对。</p><p><img data-src="5.png" alt="逆序对-2"></p><p>$3$也是如此。但到了8的时候，就会发现，此时不能将8放入区间了，并且8也不于左区间的所有数构成逆序对。</p><p><img data-src="6.png" alt="逆序对-3"></p><p>继续操作，直到9的时候，会发现此时$8$与左区间剩余的$9$成逆序对，并且该把$8$放入区间。</p><p>由此我们可以得到规律：</p><p><strong>在归并排序合并区间的时候，若该将右区间的某个数放入合并区间时，左区间剩余的数都与这个数构成1逆序对</strong>。</p><p>所以我们假设左区间目前剩余的第一个数的下标为$i$，左区间的末端下标为$mid$，那么每当一个右区间的数放入左区间时，逆序对的个数就增加$mid-i+1$。</p><p>所以我们需要在原来归并排序的代码上改动如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=r)<span class="comment">//保证i一定在左区间并且j一定在右区间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i]&lt;=a[j])<span class="comment">//左区间的第一个数大于右区间的第一个数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        comb[k]=a[i];<span class="comment">//comb代表合并在一起的区间，临时存储</span></span><br><span class="line">        i++;<span class="comment">//准备扫描左区间下一个数</span></span><br><span class="line">        k++;<span class="comment">//合并区间里面的元素个数加加</span></span><br><span class="line">    &#125;<span class="comment">//左区间的第一个数按顺序放在合并区间</span></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//右区间的第一个数大于左区间的第一个数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        comb[k]=a[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;<span class="comment">//同上理</span></span><br><span class="line">        cnt+=(mid-i+<span class="number">1</span>);<span class="comment">//逆序对的个数增加</span></span><br><span class="line">    &#125;<span class="comment">//右区间的第一个数按顺序放在合并区间</span></span><br><span class="line">&#125;<span class="comment">//这样操作之后左区间或者右区间有可能没被扫描完，因为i和j有一个会先到达边界</span></span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 111111</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],comb[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r)<span class="comment">//拆分到底的情况</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//二分继续拆分</span></span><br><span class="line">merge_sort(l,mid);<span class="comment">//左子区间</span></span><br><span class="line">merge_sort(mid+<span class="number">1</span>,r);<span class="comment">//右子区间</span></span><br><span class="line"><span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line"><span class="comment">//i代表左区间目前扫描到的数的位置，j代表右区间目前扫描到的数的位置</span></span><br><span class="line"><span class="comment">//k代表合并区间目前最后一个数在合并区间的位置，对应的是合并之后这个元素在原序列中的位置</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=r)<span class="comment">//保证i一定在左区间并且j一定在右区间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]&lt;=a[j])<span class="comment">//左区间的第一个数大于右区间的第一个数 </span></span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[i];<span class="comment">//comb代表合并在一起的区间，临时存储</span></span><br><span class="line">i++;<span class="comment">//准备扫描左区间下一个数</span></span><br><span class="line">k++;<span class="comment">//合并区间里面的元素个数加加</span></span><br><span class="line">&#125;<span class="comment">//左区间的第一个数按顺序放在合并区间</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//右区间的第一个数大于左区间的第一个数 </span></span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[j];</span><br><span class="line">j++;</span><br><span class="line">k++;<span class="comment">//同上理</span></span><br><span class="line">cnt+=(mid-i+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">//右区间的第一个数按顺序放在合并区间</span></span><br><span class="line">&#125;<span class="comment">//这样操作之后左区间或者右区间有可能没被扫描完，因为i和j有一个会先到达边界</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid)    </span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[i];</span><br><span class="line">i++;</span><br><span class="line">k++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;=r)     </span><br><span class="line">&#123;</span><br><span class="line">comb[k]=a[j];</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="comment">//把这两个小区间没有分到合并区间都分过去</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;i++)   </span><br><span class="line">a[i]=comb[i];<span class="comment">//把原来的两个区间更新为现在已经找计算来的合并区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">merge_sort(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,a[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 知识点 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
            <tag> 基本算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>No gini</title>
      <link href="%E6%96%87%E7%AB%A0/No-gini/no-gini/"/>
      <url>%E6%96%87%E7%AB%A0/No-gini/no-gini/</url>
      
        <content type="html"><![CDATA[<p>《她来听我的演唱会》，在不知道第多少遍的时候，我才明白，这不是一首歌，是一个故事，这一个故事。这首歌，道尽了一个女人的一身；以一个男人的角度，道尽了一个女人的一身。从17岁，到25岁，再到33岁，最后到40岁。从初恋第一次约会，到恋爱是风光明媚，再到真爱那么珍贵，最后到听歌的女人很美。这一切，看起来都是那么的和谐。除了40岁时，听歌的女人很美。</p><p>歌曲在40岁结束了。为什么是40岁？为什么前面都是讲的爱情，而40岁时，却话锋突变，转而是听歌的女人很美？是巧合？还是蓄意而为？</p><a id="more"></a><p>40岁，到底是结束，还是开始？</p><p>其实这一切都应该从17岁开始说起吧。</p><p>“她记得月台汽笛声声在催，播我的歌陪着人们流泪”。离别时就注定了，会再次相遇。那时的感情，单纯，洁白。在两人的心中，接下来的感情，会充满光明，充满希望。可万万没想到，这一切，都会在月台汽笛声响起的时候，被按下暂停，或者按下结束。这，是初恋，青涩的初恋。</p><p>“成年人分手后都像无所谓，和朋友一起买醉卡拉OK”。无所谓，真的无所谓？也许表面上只是轻描淡写，但谁能明白，心中的伤痕，有多大？成年人，哪怕再痛，也只能面对现实，暗地里舔舐自己的伤口。也许酒精的发明，就是为了让人短暂的逃避现实，度过本该有的最痛苦的那段时光。谁能想到，前一秒让你疼爱的人，后一秒就背着自己送人玫瑰。</p><p>“她努力不让自己看来很累，岁月在听我们唱无怨无悔”。时间的流逝，对于一部分人来说，也标志着真爱会越来越寻找。也许现在的一个选择，将会决定自己的下半辈子，会过上什么生活。为什么会努力让自己看上去不累？为了给对方减少负担。之后的生活，将会越来越快，越来越难。为了生活，必须找一位真正爱自己的人，与自己共度余生，远走高飞。</p><p>“身边的男人早已渐渐入睡，她静静听着我们的演唱会”。人生近半，生活会越来越千篇一律，时间也会越来越快。自己过上了稳定而又幸福的生活。回顾那些自己走过的路，虽然有些坎坷，但却是爱情的一个又一个点缀，装饰了这份洁白的爱情，让它不那么孤单。当年的生活是那么美好，那么甜蜜，好想回到当年，再次感受那种感觉……可看着自己身边的人，以及熟睡的孩子，只能摇摇头，回到现实中，静静的欣赏两人这一生的演唱。</p><p>也许这一生，就是一场演唱会。一个在唱，一个在听。一个唱的心碎，一个听的心碎。时间流逝，人在变化，从单纯，到成熟。也许回顾当年的爱情，也是爱情的一部分。</p><p>看到一个评论，是最后一句歌词的改版：</p><p>四十岁我们再相遇，你问我什么是风花雪夜，我说 一个成语而已。</p><p>是否感觉，有一丝遗憾，一丝无奈？</p><p>那还有一个评论，是这样说的：</p><p>人不能为了尊严，钱都不要了吧？</p><p>是否觉得，有一丝痛苦，一丝绝望？</p><p>也许这个社会，是一把刀，它抹去了人们最美丽的那一面，最质朴的那一面，最浪漫的那一面。这个世界上有多少过于物质的人？那些拜金女，还有那位多年前在某个舞台上说“宁愿坐在宝马车里面哭，也不愿意坐在自行车后笑”的那位女孩，现在过得怎么样？</p><p>这个世界太物质，因为所谓的“经济”，失去了多少东西？人类丧失了诗意，让电视剧和歌手变成了金钱与物质；人类丧失了好奇，在几十年前说的短时间内就能登上火星为什么现在还没实现？人类丧失了浪漫，让本该挥洒浪漫的青春变成了为了过得不比某某某差的打拼；人类丧失了友情，创业前在烧烤店一起喝夜啤酒的兄弟，在公司做大之后变成了只有在一起谈钱谈钱谈钱；人类丧失了亲情，让本来血浓于水的兄弟姐妹们因为家庭背景的原因变得不得不对某个兄弟姐妹毕恭毕敬！人类还丧失了同情，眼看着当今社会有那么多人买不起房，还不停的炒房炒房，让房价飞升，自己获利，无数人失去了家庭！人类丧失了尊严，为了钱，为了未来，有多少人忍声吞气，放下尊严，开始为生存斗争？</p><p>因为太物质，人类丧失了什么？人类丧失了诗意，丧失了好奇，丧失了友情，丧失了亲情，丧失了同情，还丧失了尊严！人类再丧失，就要变成丧尸了！这还是人吗！</p><p>哪怕是人类的人生分为从满足温饱到尊严这几个阶层，也不至于丧失那么多吧？动物有兽性，但动物绝对不会丧失友情与亲情，更不会丧失好奇！那人类现在算什么，动物都不如吗？</p><p>人在漫长的进化中，到底是在进步，还是在退步？到底是在前进，还是在后退？</p><p>人类再总结为什么贫富差距这么大的时候，总是会觉得全是穷人的错误：他们没有上进心，他们好吃懒做，他们不懂得珍惜。中国在2020年所有人脱贫，全面奔小康。但在所有人都脱贫之后，人们才会发现：穷人富有了，但富人却更富有了。我们总是想尽办法做到Less Gini，但我们的所作所为却导致了More Gini。难道穷人富有了，贫富差距就会减小吗？真的全是穷人的错吗？</p><p>我看未必。</p><p>世界的经济正在趋于一个形式：世界上99%的财产都将聚集在1%的人手里。这是多么恐怖的一件事。为什么会这样？因为贫富差距在越来越大，全世界的所有人联合起来努力一辈子，也许还没有某个人动一个手指的力量强大。我们都看到了，经济在发展，看上去真的很美好啊，但为什么，自己钱包里面的钱越来越少了？自己的花呗还起来越来越吃力了？</p><p>因为这个世界太物质了，所有人都只看表面，埋没了多少人才？扼杀了多少感情？摧毁了多少家庭？如果人类再诗意那么一些，再对世界好奇一些，再有友情一些，再有亲情一些，再有同情一些，对钱再看淡一些，这个世界还会那么肮脏吗？</p><p>如果全世界都实现了共产主义社会，那贫富差距还会存在吗？人类还会把那么多的尽力投放在所谓的只封闭在这个星球上的经济上面吗？人类还会那么物质吗？</p><p>为什么贫富差距越来越大？因为所有的机会，都被富人抢走了。一个穷人攒钱一辈子，在买房那一刻却被富人涨价，那是多么的心酸？这个世界的机会真的是平等的吗？这真的是一个平等的世界吗？如果人类再追求那些所谓的经济，这个世界还会那么肮脏吗？</p><p>但愿有生之年，我能看到贫富差距越来越小，我能看到人类越来越诗意，再也不那么现实，越来越有情，丢弃那些所谓的经济，奔现真正的富有，实现真正的共产主义，0贫富差距，No Gini。</p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状压DP-枚举子集</title>
      <link href="OI/%E9%A2%98%E8%A7%A3/UVA/%E7%8A%B6%E5%8E%8BDP-%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/%E7%8A%B6%E5%8E%8Bdp-%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/"/>
      <url>OI/%E9%A2%98%E8%A7%A3/UVA/%E7%8A%B6%E5%8E%8BDP-%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/%E7%8A%B6%E5%8E%8Bdp-%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>鉴于状压DP真的没什么好说的，我们还是先看题目。</p><a id="more"></a><p><strong>例1</strong>.<a href="https://www.luogu.com.cn/problem/UVA11825">UVA 11825</a>  （<a href="https://onlinejudge.org/external/118/p11825.pdf">原题PDF下载</a>）</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Miracle Corporations has a number of system services running in a distributed computer system which is a prime target for hackers. The system is basically a set of $N$ computer nodes with each of them running a set of $N$ services. Note that, the set of services running on every node is same everywhere in the network. A hacker can destroy a service by running a specialized exploit for that service in all the nodes. </p><p>One day, a smart hacker collects necessary exploits for all these $N$ services and launches an attack on the system. He ﬁnds a security hole that gives him just enough time to run a single exploit in each computer. These exploits have the characteristic that, its successfully infects the computer where it was originally run and all the neighbor computers of that node.</p><p>Given a network description, ﬁnd the maximum number of services that the hacker can damage.</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>There will be <strong>multiple test cases</strong> in the input ﬁle. A test case begins with an integer $N (1\leq N\leq 16)$, the number of nodes in the network. The nodes are denoted by $0$ to  N−1. Each of the following $N$ lines describes the neighbors of a node. Line $i(0 \leq i &lt;N)$ represents the description of node $i$. The description for node $i$ starts with an integer $m$ (Number of neighbors for node $i$), followed by $m$ integers in the range of $0$ to N−1, each denoting a neighboring node of node $i$.</p><p>The end of input will be denoted by a case with $N=0$. This case should not be processed.</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>For each test case, print a line in the format, ‘Case X: Y ’, where $X$ is the case number &amp; $Y$ is the maximum possible number of services that can be damaged.</p><h3 id="样例数据"><a href="#样例数据" class="headerlink" title="样例数据"></a>样例数据</h3><p>input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 2</span><br><span class="line">2 0 2</span><br><span class="line">2 0 1</span><br><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 0</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 3</span><br><span class="line">Case 2: 2</span><br></pre></td></tr></table></figure></p><h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>在一个计算机网络中，有n台计算机（分别以$0-(n-1)$编号），且给出网络的联通情况。共有$n(n\leq 16)$种服务，每个计算机都运行着这$n$个服务。假如你是一个黑客，你可以侵入任意一台计算机，并且终止这台计算机的任意一项服务。此时这台计算机所直接联通的所有计算机的这一项服务都会被终止。每台电脑只能被入侵一次，每一次只能终止一项服务，求最多能使多少服务瘫痪。（服务瘫痪：这个服务在所有的计算机上都被终止）。</p><p>有<strong>多组测试数据</strong>，对于每组数据，第一行一个数$n$，表示计算机数和服务数。接下来$n$行每行一个数$k$，表示第$i$台电脑连接的电脑数为$k$，然后$k$个数表示连接的电脑的编号。对于第$i$组数据，输出格式为：Case “数据组数”: “最多能使多少台服务瘫痪”。</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>首先，因为要使瘫痪的服务数尽量的多，所以我们考虑使想要终止的服务尽量瘫痪。假设我们终止了第i台计算机的第j个服务，那么它周围一圈的计算机的这个服务都会被终止。因为要使这个服务瘫痪，所以要使所有计算机中除了这个服务终止了的所有计算机这项服务都瘫痪。因为要使终止的服务数最多，所以终止这个服务的计算机尽可能的小。换一种方式，我们假设第i台计算机连着的计算机（包括自己）的几何为$p[i]$，全集$U$为所有计算机，所以我们要使$\complement p[i]$里的计算机的这项服务终止。但是因为终止一个计算机的一项服务可能会影响到其他计算机的这项服务，所以$\complement p[i]$一定是终止这项服务其他的计算机（假定编号为x），也就是p[x]的子集。那么我们要尽可能使$\complement p[i]$和p[x]的非公共元素最少。</p><p>为了方便表示集合，我们将集合状压，也就是p[i]这个二进制数的第$j$位（从右往左，$j$从0开始）若为1表示第$i$台计算机与第$j$台计算机相连。所以我们要枚举全集$U$的子集，使得其中一些子集（不重复）的并集为全集。为了使答最优，我们要使得子集的个数尽量少。</p><p>所以现在问题变成了：给出全集$U$，求这$n$个集合最多分成多少组，使得每一组集合的并集是全集。</p><p>我们开始设计状态：令dp[i]表示状态为$i$（i为一个二进制数，为1的位的几何表示这几台电脑分为一组）时分组。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
          <category> UVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
            <tag> DP </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速度，加速度，位移</title>
      <link href="%E5%AD%A6%E4%B9%A0/%E6%96%87%E5%8C%96%E8%AF%BE/%E7%89%A9%E7%90%86/%E8%BF%90%E5%8A%A8%E5%AD%A6/%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%EF%BC%8C%E4%BD%8D%E7%A7%BB/%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%EF%BC%8C%E4%BD%8D%E7%A7%BB/"/>
      <url>%E5%AD%A6%E4%B9%A0/%E6%96%87%E5%8C%96%E8%AF%BE/%E7%89%A9%E7%90%86/%E8%BF%90%E5%8A%A8%E5%AD%A6/%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%EF%BC%8C%E4%BD%8D%E7%A7%BB/%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%EF%BC%8C%E4%BD%8D%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p>在学习之前，我们先归纳一下我们初中学过的一些物理量：时间，路程，速度，热量，力，压强……在我们现在知识的基础上，“力”这个物理量应该是当中最特殊的了。因为在我列举的几个物理量中，力是唯一一个有方向的物理量。为了区分这种物理量，我们规定，在物理学中，<strong>既有大小又有方向的量叫做矢量；只有大小没有方向的量叫做标量。</strong></p><a id="more"></a><p>矢量和向量的差别就在于，矢量有方向。那我们如何表示一个矢量的方向呢？对于下面这个例子，我们分别是这样表示这几个力的：<img data-src="1.png" alt="图1"></p><blockquote><p>F1=10N,方向竖直向上；<br>F2=16N,方向竖直向下；<br>F3=3N,方向水平向左；<br>F4=8N,方向水平向右；<br>F5=6N,方向向右上方；</p></blockquote><p>所以我们知道了矢量的表示方法：文字上：<strong>先表示大小，再表示方向</strong>；图像上：一个带箭头的有向线段。但是问题来了：如果右上方有两个力，那如何区分呢？当我们知道它和水平面的夹角时，我们可以这样说：</p><blockquote><p>F5=37°,方向沿水平面37°向右上。</p></blockquote><p>但是这样的话，我们运算的时候就会觉得特别的不方便：运算过程中还要写这么多文字。并且在高中物理里，大量矢量的运算一般都是在一条直线上（平行四边形法则题和少数毒瘤竞赛题除外）。所以为了方便运算，我们一般把矢量的方向用$+$或$-$号来表示。首先，我们先定义一个方向为正方向，如果某个矢量的方向与正方向相同，这个矢量就为正（也就是前面的符号为0，一般不写）；如果这个矢量的方向与正方向不同，这个矢量就为负（也就是前面加一个负号）。这么写的好处是，我们不但能表示出矢量的方向，并且在运算中也很方便。具体的矢量运算法则我们后面再讲。<br><strong>注意：矢量和标量的性质很重要，因为在后面我们每接触一个物理量，首先要分析的应是“这个物理量是标量还是矢量”。</strong></p><p>在高中物理中，经常会遇到一些求变化量的题目。但是到底什么才是变化量？是看变多的还是变少的？我们可以形象举个例子。第一天，我手里有10元钱；第二天，我手里有20元钱；第三天，我手里有10元钱。在这个例子中，第二天和第三天我手里钱的变化数目都是10元钱。但是实际上，第二天我的钱变多了，第三天我的钱变少了。所以在物理学科上，我们定义一个物理量的变化量$\Delta x=x_{t}-x_0 $。</p><p>那么开始正戏：我们再引入几个物理量：速度，加速度，位移，时间。时间就不用多说了，标量，符号表示为$t$，单位为秒（$s$）。第二个，就是位移。根据字面意思来理解，就是物体位置的移动。但是注意，位移和初中所学的路程不同：位移相当于是初态到末态的连线，而路程是物体经过的长度的总和。所以如果我们以某个点为圆心，绕着它走一圈，最后所经过的路程是圆的周长，但是所经过的位却是0.但是需要注意的是：<strong>位移是个矢量</strong>。因为在这里，位移其实是一个从起点指向终点的矢量。所以位移：符号$x$，单位（国际单位）米（$m$），矢量。<br><img data-src="2.png" alt="图2"></p><p>虽然速度$v$这个物理量，我们在初中学过,但是速度在初中的定义是$v=\frac{s}{t}$。但是在高中物理中，速度的定义是<strong>位移与时间的比</strong>（$v=\frac{x}{t}$）。所以在上图中的人的速度应该为0。那是不是意味着我们初中学的速度就错了呢？并不是。因为大多数时候，初中物理所用到的速度大多是在一条直线上。所以这种情况下，<strong>只要不存在折返的情况</strong>，位移就等于路程。所以这时候就有一道比较骚的题目来了（填空题）：<br><img data-src="3.png" alt="图3"></p><pre><code>滑动我看答案-------------------------------------------------------------------------------------------------------------------------------答案：|h_t-h_0|，方向竖直向下。</code></pre><p>是不是被骚到了？所以我们来看一下这道题的几个考点和坑点：</p><ol><li>位移是矢量，要答出方向和大小</li><li>$h_t$和$h_0$都是位置，而不是长度</li><li>矢量的大小一定是非负数</li></ol><p>所以我们可以总结出一些东西：</p><ol><li>问一个矢量的时候，要看清楚是不是只问了大小，如果不是还必须答出方向</li><li>矢量的大小一定是非负数</li></ol><p>我们还是按照刚才说的，先看一下速度的性质：标量还是矢量。其实，速度是个标量。我们还是来看速度的定义式：$v=\frac{x}{t}$。在这里面，$x$是矢量，$t$是标量，所以$v$一定是矢量。那速度的方向是什么呢？就是位移的方向。所以速度：矢量，符号$v$，单位（国际单位）米每秒（&amp;m/s&amp;）。</p><p>但是其实我们现在所说的速度，只能叫做平均速度，因为我们并没有说物体在匀速直线运动。那物体的瞬时速度怎么求呢？可以采用<strong>微元法</strong>。也就是说，当$t$趋近于0的时候，速度就趋近于这个点的瞬时速度了。</p><p>我们还会接触到一个物理量，叫做速率。这个物理量是个标量。由于我也一直没搞清楚这个到底是什么（百度上也说得比较模糊），我们就摘录一段维基百科的解释：</p><blockquote><p>速率（英语：Speed）是物理学中的一个基本概念，是指物体在单位时间内经过的路程，用来表示物体运动的快慢程度。</p></blockquote><p>那么同理，平均速率的求法与平均速度的求法大致相当。</p><p>因为在生活中，并不是所有时候速度都不变的。所以物理学家们引入了一个物理量：<strong>加速度</strong>。既然我们要研究速度的变化量，那什么是速度的变化量呢？根据上面的铺垫，我们可以得出：速度的变化量为末速度减初速度。写成公式的形式，就是$\Delta v=v_t-V-0$。（在物理学中，我们通常用$\Delta$表示某个物理量的变化量，用下标区分不同物体不同时候的某一个物理量。一般用下标$t$表示“末”状态，用下表$0$表示“初”状态）某些时候，速度的变化量又可以叫做速度的<strong>增量</strong>。但这个“增”又不一定是增加的意思，也可以表示减小。所以我们可以得到：<strong>物理量的增量是末减初，物理量的减量是初减末。</strong></p><p>我们来分析速度增量这个物理量：因为是矢量相减，所以还是矢量。那它的方向是什么呢？由于现阶段我们研究速度的方向一般都是在一个平面内，所以，对于现在的题目而言：它的方向不是正的就是负的。所以他的方向我们根本不用考虑太多：就是说得答案的正负号。注意在做此类题目的时候，题目是否告诉了哪个方向为正方向。</p><p>但是有的时候，我们会遇到初速度和末速度方向不一样，这时候该如何计算呢？我们举几个例子（填空题）：<br>均以向右为正方向，求速度变化量。<br>（1）<br><img data-src="4.png" alt="图4"><br>（2）<br><img data-src="5.png" alt="图5"><br>（3）<br><img data-src="6.png" alt="图6"><br>（4）<br><img data-src="7.png" alt="图7"></p><pre><code>滑动我看答案----------------------------------------------------------------------------------------------------------答案：(1) 2m/s    (2) -6m/s       (3) -15m/s       (4) 18m/s</code></pre><p>做这种题，一般的方法是，先以题目告诉的正方向负方向，把所有的速度符号标出来，然后运用公式$\Delta v=v_t-v_0$求出答案。这样的确可以。但是我比较喜欢用另一种方法：先画出一个数轴，原点为物体所在的地方。然后向左和向右的速度分别画在数轴的左右两端，然后两个终点之间的距离即为答案的大小，末速度的终点指向初速度的终点的方向即为$\Delta v$的方向。但是值得一提的是，这种题虽然我们用正负号表示了速度增量的方向，但是保险起见，我们还是应该在竖直的后面写上方向。<strong>如果题目明确规定了是求大小，就不要写方向了。</strong></p><p>对于实际应用题而言，如果没有告诉正方向，那就默认初速度方向为正。</p><p>我们在生活中，判别一辆跑车的标准，通常是百公里加速的时间。其实我们比较的是同样大小的时间，速度的变化量。所以我们有了一个物理量，来说明单位大小的时间内物体速度的变化量：<strong>加速度（acceleration）</strong>。所以我们可以得出加速度的定义：速度变化量与时间的比值($a=\frac{\Delta v}{t}$)。所以加速度：符号$a$，<strong>矢量</strong>（因为$\delta v$是矢量，$t$是标量，所以$a$是矢量），单位米每二次方秒（$m/s^2$，因为$\Delta v$的单位是$m/s$，$t$的单位是$s$，所以单位相除得到$m/s^2$）。<strong>加速度是描述物体速度变化快慢的物理量</strong>。当然，这儿的加速度应该是平均加速度。</p><p>这时候又来了一道骚题，不过我们还是当做例题来讲吧：<br><strong>已知物体的初速度，末速度，加速度，求物体是做加速运动还是减速运动</strong>。<br><img data-src="8.png" alt="图8"></p><pre><code>滑动我看答案-------------------------------------------------------------------------------答案：（1）加速   （2）减速   （3）加速   （4）减速</code></pre><p>所以肯定会有人迷惑了：为什么速度变小了还是加速运动呢？我们先来回顾一下加速度和速度这两个东西。首先，它们是个矢量。对，它们是矢量！所以我们给矢量比较大小的时候，就一定是比较其绝对值，而不是把符号也算上。就相当于我们跳远比赛的时候，可能规定了两个不同的不一定在一条直线上的跳的两个方向，然后两个人跳出的成绩，我们是只看长度而不会看方向的。<strong>矢量大小的比较要取绝对值</strong>。</p><p>所以现在应该明白答案是怎么来的了吧：（1）末速度大于初速度：加速   （2）末速度<strong>小于</strong>初速度：减速   （3）末速度大于初速度：加速   （4）末速度小于初速度：减速。</p><p>我们来看一道变式训练：<br><img data-src="9.png" alt="tmpe.png"></p><pre><code>滑动我看答案------------------------------------------------------------------------------------答案：（1）先减速后加速   （2）先减速后加速</code></pre><p>其实这道题和例题差不多，只是我们需要明白：加速度恒定的时候，物体不一定只做加速或减速运动。对于这种题，我一般的解决方法是：</p><ol><li>判断情景是否合理（比如说，初速度为$1m/s$，末速度为$3m/s$，但加速度为$-2m/s^2$，就不合理）。若不合理直接返回答案不合理，结束；否则继续。</li><li>判断初速度和末速度方向是否一样，如果一样则继续，否则跳到4。</li><li>判断加速度和初速度（末速度）方向是否一样，如果一样，则返回答案加速运动，否则返回答案减速运动。结束。</li><li>初末速度方向不一样，由于<strong>加速度没有变化</strong>，一定是先减速后加速。</li><li>结束</li></ol><p>处理这一类问题，我们可以用模拟的方法。在数轴上画出初速度与末速度的位置，加速度的方向就只能是正方向或者负方向。然后我们假设有一个点，从初速度的位置，以a的大小为速度，运动到了末速度的位置，问这个点到远点的距离变化过程。这也就是我们上面的题型。当然还有一类题型，也就是告诉你初速度的正负，加速度的正负，问速度的变化，这也可以用画图的方法做。</p><p>在做题过程中，我们经常会发现，他就是不说成加速度，非要说成其他形式。比如，<strong>速度变化率</strong>，这也算加速度的一种表达方式。同样，速度变化率也就是单位时间内的速度增量。那有其他变化率吗？有，基本来说<strong>比值定义法</strong>（也就是某个物理量与时间的比定义出来的物理量）定义的物理量都可以说成~变化率。比如速度我们可以说成是位移变化率。</p><p>对于加速度的简单计算，其实我们也已经提到过了。因为$a=\frac{\Delta v}{t}$，上面我们又讲了$\Delta v$的计算方法，所以加速度就只需要除以一个$t$。</p><p>最后，我们来看一下第一章第一节的内容（最简单的内容）：质点、参考系、空间与时间。首先，参考系，也就是初中说的参照系，应用一段维基百科的讲解:</p><blockquote><p>在物理学中指用以测量并记录位置、定向以及其他物体属性的坐标系；或指与观测者的运动状态相关的观测参考系；又或同指两者。</p></blockquote><p>质点，也就是一个有质量的点，这是物理学家运用了理想模型法的方法，为了方便的解决问题而提出的。一个简单的例子：<br>天体运动学家们研究哈雷彗星运动轨道时，可以把哈雷彗星看做质点。<br>研究扇耳光时脸的形变，不能把人脸看做质点。</p><p>所以我们可以总结：</p><ol><li>在研究物体运动时,其大小与形状可以不考虑时,可以视为质点；</li><li>物体<strong>各部分运动情况相同</strong>,在研究其运动规律时,可以视为质点；</li><li>物体平动时,可以视为质点 如果物体上各点得运动情况完全相同,或者物体上各点得运动得差别相对于所研究的问题来讲可以忽略,我们就可以把物体<strong>简化</strong>为一个点,认为物体的质量都集中到这个点上,这个点称为质点.</li></ol><p>然后我们需要区分的是时间和时刻。用图形化的方法来理解：时刻是一个点，时间是一条线。x秒内，这段时间有x秒；<strong>第</strong>x秒内，这段时间有1秒。还有其他的很多例子，书上都有详细的讲解。</p><p>最后对于空间、时间、物质，我们有以下结论：</p><ol><li>没有绝对空间和时间，空间和时间都是<strong>相对而言的</strong>。</li><li>现代物理学已证明，时间和空间不能离开物质而独立存在，没有绝对时空，时间、空间和物质世界是融为一体的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 文化课 </category>
          
          <category> 物理 </category>
          
          <category> 运动学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 物理 </tag>
            
            <tag> 文化课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThankU</title>
      <link href="%E6%96%87%E7%AB%A0/ThankU/thanku/"/>
      <url>%E6%96%87%E7%AB%A0/ThankU/thanku/</url>
      
        <content type="html"><![CDATA[<blockquote><p>谢谢你，让我明白了如何去爱；</p><p>谢谢你，给我生活增添一份活力；</p><p>谢谢你，让我懂得了如何被爱；</p><p>谢谢你，给我生活带来更多欢喜；</p><p>谢谢你，让我明白了我应该去努力；</p><p>谢谢你，给我的前方送来了更多希望；</p><p>谢谢你，让我知道了世界的魅力；</p><p>谢谢你，给我枯燥的生活带来一丝新颖。</p><p>无论如何，我都要谢谢你；</p><p>因为你是我生命中，最靓丽的一道风景。</p></blockquote><hr><blockquote><p>Thank you,for letting me know how to love;</p><p>Thank you,for adding a piece of erengy to my life;</p><p>Thank you,for letting me know how to be loved;</p><p>Thank you,for bringing more happiness to my life;</p><p>Thank you,for letting me know that I have to be more hardworking;</p><p>Thank you,for bringing me more hope to my freature;</p><p>Thank you,for letting me know the charm of the world;</p><p>Thank you,for bringing a piece of novelty to my boring life;</p><p>However,I want to thank u;</p><p>Because you are the best scenery of my life.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
